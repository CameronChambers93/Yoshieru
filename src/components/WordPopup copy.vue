<template>
    <div>
        <canvas id="canvas" :style="canvasStyle" />
    </div>
</template>
<script>

export default {
    components: {
        
    },
    data() {
        return {
            canvasStyle: { left: '0px', top: '0px'}
        }
    },
    created() {
    },
    props: {
        parent: {
            default: 'AUDIO',
            type: String
        },
        jpn: {
            default: '',
            type: String
        },
        eng: {
            default: '',
            type: String
        },
        popup: {
            default: () => {return {
                x: 0,
                y: 0,
                token: {ids: []}
            }},
            type: Object
        }
    },

    mounted() {
        let canvas = document.getElementById('canvas');
        let ctx = canvas.getContext('2d');
        let {text, lineCount} = this.getTextAndLineCount(this.popup.token.ids)
        canvas.height = (text.length * 30) + (lineCount * 30);        
        ctx.setTransform(this.PIXEL_RATIO, 0, 0, this.PIXEL_RATIO, 0, 0)
        this.canvasStyle.left = Math.min(this.popup.x + 5, window.innerWidth - 380) + 'px';
        let top = this.popup.y + 20;
        if ( top + 30 + (text.length * 35) + (lineCount * 30) > window.innerHeight) {
            top = Math.max(0, top - (60 + (text.length * 35) + (lineCount * 32)));   // Math.max used so popup doesn't go past window border
        }
        top = top + 'px';
        this.canvasStyle.top = top
        this.drawText(text);
    },

    computed: {
        PIXEL_RATIO: function () {
            let ctx = document.createElement("canvas").getContext("2d"),
                dpr = window.devicePixelRatio || 1,
                bsr = ctx.webkitBackingStorePixelRatio ||
                    ctx.mozBackingStorePixelRatio ||
                    ctx.msBackingStorePixelRatio ||
                    ctx.oBackingStorePixelRatio ||
                    ctx.backingStorePixelRatio || 1;

            return dpr / bsr;
        },
    },

    methods: {
        // Returns the text to be drawn and the number of lines the text will require - to be used for canvas height
        // The text is defined as an array of objects with the following properties
        //      reading: The kanji (hiragana if no kanji exists for word) followed by the hiragana of the word
        //      textLines: The parts of speech for the word, followed by the definition of the word. The text is broken up into
        //                  lines with max length of the width of the canvas
        // LineCount is used to set the height of the canvas before drawing text
        getTextAndLineCount(ids) {
            let canvas = document.getElementById('canvas')
            let ctx = canvas.getContext('2d');
            let lineCounter = 0;
            let textArray = [];
            for (let i = 0; i < ids.length; i++) {
                let idTrie = this.$store.state.dictionary.idTrie;
                let entry = idTrie.findWord(ids[i]);
                let reading = this.getReading(entry);
                let definition = this.getPosAndDefinition(entry);
                let textLines = this.getTextLines(ctx, definition, 200);
                lineCounter += textLines.length;
                textArray.push({reading, textLines});
            }
            return {text: textArray, lineCount: lineCounter}
        },
        
        // For a given entry, returns the kanji (hiragana if no kanji exists for word) followed by the hiragana of the word
        getReading(entry) {
            let reading = '';
            if (entry.keb.length)
                    reading = entry.keb[0] + '   ';
                else
                    reading = entry['r_ele'][0].reb + '   ';
            reading += ` ${entry['r_ele'][0].reb}`
            return reading;
        },
        // For a given entry, returns the parts of speech, followed by the definition of the word
        getPosAndDefinition(entry) {
            let definition = '(';
            entry.pos.forEach((item,index) => {
                definition += item + (index < entry.pos.length - 1 ? ', ' : ') ');
            })
            //for (let i = 0; i < entry.gloss.length; i++) {
            entry.gloss.forEach((gloss, i) => {
                gloss.forEach((item, index) => {
                    definition += item + ((index < gloss.length - 1 || i < entry.gloss.length - 1) ? '; ' : '');
                })
            })
            return definition;
        },
        // Draws text for the entry. Text object is generated by getTextAndLineCount
        drawText(text) {
            let canvas = document.getElementById('canvas')
            let ctx = canvas.getContext('2d');
            ctx.fillStyle = "#fbf0ff"
            ctx.fillRect(0, 0, canvas.width, canvas.height)
            let lineCounter = 0;
            for (let i = 0; i < text.length; i++) {
                ctx.fillStyle = "blue"
                ctx.font = '1.4rem bold serif'
                ctx.fillText(text[i].reading, 5, 25 + (lineCounter++ * 30))
                ctx.fillStyle = "black"
                ctx.font = '1rem serif'
                for (let j = 0; j < text[i].textLines.length; j++) {
                    ctx.fillText(text[i].textLines[j], 5, 20 + (lineCounter++ * 30))
                }
            }
        },
        // Splits text into rows with max length of maxWidth
        getTextLines(ctx, text, maxWidth) {
            var words = text.split(" ");
            var textLines = [];
            var currentLine = words[0];

            for (var i = 1; i < words.length; i++) {
                var word = words[i];
                var width = ctx.measureText(currentLine + " " + word).width;
                if (width < maxWidth) {
                    currentLine += " " + word;
                } else {
                    textLines.push(currentLine);
                    currentLine = word;
                }
            }
            textLines.push(currentLine);
            return textLines;
        }
    },

    watch: {
    }
}
</script>
<style scoped>

canvas{
    min-width: 340px;
    border: 1px solid black;
    position: fixed;
    z-index: 10;
}

.example_sentences{
    text-align: right;
}

.ex_sentence_jpn{
    font-size: 1.4rem;
}

.ex_sentence_eng{
    font-size: 1em;
    opacity: 80%;
    margin-bottom: 1rem
}

</style>